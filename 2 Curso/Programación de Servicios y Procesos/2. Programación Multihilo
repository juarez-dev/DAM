PROGRAMACIÓN MULTIHILO
Es un enfoque de la concurrencia.
Los programas realizan actividades o tareas, y para ello pueden seguir uno o más flujos de ejecución, demendiendo de su número, podemos hablar de 2 tipos de programas:
  -> PROGRAMA DE FLUJO ÚNICO, el que realiza las actvidades/tareas una a continuación de la otra, de manera secuencial, cada una de ellas debe concluir por completo antes de iniciar la siguiente.
  -> PROGRAMA DE FLUJO MÚLTIPLE, aquel que coloca las actividades a realizar en diferentes flujos de ejecución, cada uno de ellos se inicia y termina por separado, pudiéndose ejecutar de manera simultánea o concurrente.

La PROGRAMACIÓN MULTIHILO o MULTITHREADING consiste en desarrollar programas de flujo múltiple, cada flujo de ejecucion es un TRHEAD o HILO.


CONCEPTOS SOBRE HILOS
  THREAD o SUBPROCESO, flujo de control secuencial independiente dentro de un proceso y está asociado a una secuencia de instrucciones, un conjunto de registros y una pila.
  PRIMARY THREAD, el primer hilo creado, cuando se ejecuta el SO, el cual puede a su vez crear hilos adicionales.

Observaciones:
  - Un thread no puede existir independientemente de un proceso.
  - Un thread no puede ejecutarse por si solo.
  - Dentro de cada proceso puede haber varios thread ejecutándose.


RECURSOS COMPARTIDOS POR LOS THREADS

Un thread lleva asociado los siguientes elementos:
  - Un id único.
  - Un contador de programa propio.
  - Un congunto de registros.
  - Una stack.

Un thread puede compartir con otros del mismo proceso los siguiente resources:
  - Code.
  - Data (Global variables).
  - Other SO resources (open files, signals, ...).

Se hace necesario utiilizar esquemas de bloqueo y sincronicación por el hecho de que los hilos comparten recursos.


VENTAJAS SOBRE LOS PROCESOS
  -> Consumen menos recursos en el lanzamiento y ejecución.
  -> Tardan menos tiempo en crear y terminar.
  -> La conmutación entre hilos del mismo proceso o cambio de contexto es bastante más rápida.

USO DE LOS HILOS
Se aconseja el uso de los hilos cuando:
  -> La app maneja entradas de varios dispositivos de comunicación.
  -> La app debe poder realizar diferentes tareas a la vez.
  -> Interesa diferenciar tareas con una prioridad variada.
  -> La aplicación se va a ejecutar en un entorno multiprocesador.
Los threads son idóneos para programar aplicaciones de entornos interactivos y en red, asi como simuladores y animaciones.


MULTITHREADING ON JAVA
Java da soporte al concepto Thread desde el propio lenguaje, con algunas clases e interfaces definidas en java.lang y con métodos especificos para la manipulación de threads en la clase Object.
A partir de la versión 5, se incluye el paquete java.util.concurrent con nuevas utilidades para desarrollar apps multithread y aplicaciones con alto nivel de concurrencia.

En el paquete java.lang tenemos las siguientes utilidades de concurrencia:
  -> Clase thread, responsable de producir threads funcionales para otras clases y proporciona gran parte de los métodos utilizados para su gestión.
  -> Interfaz Runnable, proporciona la capacidad de añadir la funcionalidad de hilo a una clase implementando la interfaz, en lugar de derivandola a la clase thread.
  -> Clase ThreadDeath, una clase de error, deriva de la clase Error y proporciona medios para manejar y notificar errores.
  -> Clase ThreadGroup, se utiliza para manejar un grupo de hilos de modo conjunto, de manera que se pueda controlar su ejecución de forma eficiente.
  -> Clase Object, no es estrictamente de apoyo a los hilos, pero proporciona métodos cruciales dentro de la arquitectura multihilo de Java -> wait(), notify(), notifyAll().

El Paquete java.util.concurrent incluye clases que facilitan el desarrollo de apps multihilo y apps complejas porque estan concebidas para utilizarse con bloques de diseño.
Estas utilidades están dentro de los siguientes Paquetes:
  -> java.util.concurrent:
    - Clases de sincronización -> Semaphore, CountDownLatch, CyclicBarrier y Exchanger.
    - Interfaces para separar la lógica de la ejecución -> Executor, ExecutorService, Callable y Future.
    - Interfaces para gestionar colas de hilos -> BlockingQueque, LinkedBlokingQueque, ArrayBlockingQueque, SynchronousQueque, PriorityBlockingQueque y DelayQueque.
  -> java.util.concurrent.atomic, incluye clases para ser usadas como variables atómicas en aplicaciones multithread y con diferentes data types -> AtomicInteger, AtomicLong.
  -> java.util.concurrent.locks, define clases como uso alternativo a la clausa sinchronized, se encuenran algunas interfaces como -> Lock, ReadWriteLock.


CREACIÓN DE THREADS
En java se representan mediante una instancia de la clase java.lang.thread, este objeto se emplea para inicar, detener o cancelar la ejecución de un thread.

Los thread se pueden implementar o definir de 2 formas:
  -> Extendiendo la clase thread.
  -> Mediante la interfaz Runnable.
En ambos, se debe proporcionar una definición del método run(), el cual contiene el código que ejecutará el hilo, es decir, su comportamiento.

-> Extender la clase thread es el procedimiento más sencillo, pero si la clase ya hereda alguna otra, no se puede heredar thread tambien, por lo que habrá que recurrir al procedimiento.
-> Implementar Runnable is always possible, es el procedimiento más general y el más flexible.

* Cuenado JVM arranca en la ejecución de un programa, hay un thread ejecutnadose (Main Thread) controlado por el método main(), que se ejecuta al inicio del programa y es el último que termina su ejecución.

EXTEDNS THREAD
  -> Se crea una new class que herede la clase thread.
  -> Se redefine el método run() con el código asociado al hilo, las secuencias que ejecutará.
  -> Se crea un objeto de la nueva clase thread, que será realmente el hilo.
Para iniciar el hilo una vez creado:
  -> Invocar el método start() del objeto thread creado.

IMPLEMENTS RUNNABLE
  -> Declarar new class implements Runnable.  
  -> Redefinir en la class el metódo run() con el código asociado al thread.
  -> Crear un objeto de la class.
  -> Crear un objeto de la class thread pasando como argumento al constructor el objeto cuya class tiene el método run(), que sera el thred.
Para iniciar el thread e iniciarlo:
  -> Invocar el método start() del objeto thread.


ESTADOS DE UN THREAD
El ciclo de vida de un thread comprende los diferentes estados en los que puede estar un thread desde que se crea hasta que finaliza:
  -> New, se ha creado pero aún no está disponible para su ejecución.
  -> Runnable, está preparado para ejecutarse.
Puede estar ejecutandose, siempre y cuando se le haya asignado un procesamiento, o que no este ejecutandose en beneficio de otro hilo, en cuyo caso esta Preparado.
  -> No runnable, podría estar ejecutándose, pero alguna actividad interna al propio thread se lo impide.
Si un thread esta en No Ejecutable no tiene oportunidad de que se le asigne tiempo de procesamiento.
  -> Terminated, ha finalizado, la fomra natural de terminated thread es finalizando su método run().

El metodo getState() de la class thread, permite obtener el estado en el que se encuentra el thread, devuelve:
  - RUNNABLE.
  - NO RUNNABLE.
  - TERMINATED.


INICIAR UN HILO
Cuando se crea un thread mediante el método new(), no implica que se pueda ejecutar, para ello debe estar en estado Runnable y para esto es necesario iniciarlo mediante el método start() de la clase thread.

El método start() realiza las siguientes tasks:
  -> Crea los resources del sistem necesarios para ejecutar el thread.
  -> Se encarga de llamar a su método run() y lo ejecuta como un subroceso nuevo e independiente.

Consideraciones importantes:
  -> Se puede invocar directamente run() y se ejecutara el código asociado al método dentro del thread actual, pero no comenzará un nuevo hilo como subproceso independiente.
  -> Una vez llamado al metodo run() de un threadddddddddd, no se puede volver a realizar otra llamada al mismo método, si no, se obtendra una IllegalThreadStateException.
  -> El orden en que se inician los thread mediante start() no influye en el orden de ejecución de los mismos -> El orden de ejecución de los hilos es NO-DETERMINÍSTICO.


DETENER TEMPORALMENTE UN THREAD
Significa que ha pasado al estado no runnable.
Un thread pasara a no runnable cuando se de alguna de las siguientes circunstancias:
  -> El thread se ha dormido, se ha invocado sleep() de la clase thread, indicando el tiempo que permanecerá detenido, transcurrido se vuelve Runnable, en concreto a Preparado.
  -> El thread está esperando, detiene su ejecución mediante la llamada al método wait() y no se reanudará, pasará a Ejecutable cuando se produzca una llamada a notify() o notifyAll() por otro thread.
  -> El thread se ha bloqueado, está pendiente de que finalice una operación EE/S en algun dispositivo, o a la espera de algún otro topo de recurso, cunado finaliza el bloqueo vuelve a Ejecutable -> Preparado.

El método suspend() (en desuso) también permite detener temporalmente un thread y en este caso lo reanuda resume(), no son seguros y provocan muchos problemas.


FILANIZAR UN THREAD
La forma natural de que muera un thread es cuando termia de ejecutarse su método run(), pasando a estado dead.

Para realizar otra vez el trabajo desempeñado del thread, hay que:
  -> Crear un nuevo thread con new()
  -> Iniciar el thread con start()

isAlive() de la clase thread devuelve:
  -> true si el método esta alive, el thread esta recién creado o un dead thread.
  -> false si el método no está alive, el thread se encuentra ejecutablo o no ejecutable.
Un thread esta alive desde la llamada de su método start() hasta su muerte.


DORMIR UN THREAD CON sleep()
El método sleep() de la class thread recibe como parámetro el tiempo que queremos dormir un thread que lo invoca, despues vuelve a estar Runnable (Ready) para seguir ejecutandose.

Dos formas de llamar al método:
  -> Pasar el tiempo en milisegundos positivo.
  -> Agregar un segundo argumento entero (entra 1 y 999999), el cual, representa un tiempo extra en nanosegundos que se sumará al primer argumento.

* Cualquier llamada al método sleep() puede provocar una exepción, el compilador nos obliga a controlarla mediante un bloque try-catch.


GESTIÓN Y PLANIFICACIÓN DE THREADS

La EJECUCIÓN DE THREADS, requiere la planificación de una secuencia de ejecución (scheduling), y se puede realizar mediante:
  -> PARALELISMO, en un sistema con múltiples CPUs, cada uno puede ejecutar un thread diferente.
  -> PSEUDOPARALELISMO, cuando no es posible el paralelismo, una CPU ejecuta múltiple threads.

El SHEDULER es el planificador de threads de Java, utiliza un algoritmo de secuenciación de threads denominado fixed priority scheduling que se basa en un sistema de prioridades relativa,
de manera que el algoritmo secuencia la ejecución de threads en base a la prioridad de cada uno de ellos.
El FUNCIONAMIENTO DEL ALGORITMO es el siguiente:
  -> El thread elegido para ejecutarse, siempre es el Runnable de prioridad más alta.
  -> Si hay más de uno con la misma prioridad, el orden se maneja mediante un algoritmo por turnos (ROUD-RUBIN) basado en una cola circular FIFO.
  -> Cuando el thread que esta ejecutandose pasa al estado no ejecutable o muerto, se selecciona otro thread para su ejecución.
  -> La ejecución de un thread se interrumpe, si otro thread con prioridad más alta se vuelve Runnable -> PREEMPTIVE SHEDULING, cuando un thread con una priority mas alta interrumpa a otro.

La responsabilidad de ejecución de thread se del SO sobre el que corre la JVM y cada uno tiene un manejo distinto:
  -> SO QUE IMPLEMENTA TIME-SLICING (subdivisión de tiempo), el thread que entra en ejecución se mantiene en ella sólo un micro-intervalo de tiempo fijo o quantum de procesamiento,
de manera que el hilo ejecutandose no es solo interrumpido por otro con priority mas alta se vuelve ejecutable, sino que también cuando su cuanto de ejecución se acaba.
  -> SO QUE NO IMPLEMENTA TIME.SLICING, el hilo que entra en ejecución es ejecutado hasta su muerte, salvo que regrese a no ejecutable y otro hilo de prioridad más alta alcance el estado de ejecutable.


THREAD PRIORITY
Cada thread tiene su prioridad representada por un valor entero entre 1 y 10, cuanto mayor sea el valor, mayor es la prioridad.

El main thread siempre es creado con prioridad 5.
El resto de secondary threads heredan la prioridad que tenga en ese momento el hilo padre.

En la clase thread se definen 3 constantes para menejar prioridades:
  - MAX_PRIORITY(=10), valor que simboliza la mayor prioridad.
  - MIN_PRIORITY(=1), valor que simboliza la menor prioridad.
  - NORM_PRIORITY(=5), valor que simboliza prioridad normal, la que tiene por default el thread donde corre el método main().

Se puede obeter y modificar la thread priority mediante los siguientes métodos de la clase thread:
  -> getPriority(), devuelve la prioridad del thread.
  -> setPriority(), modifica la prioridad del thread.

* Cada sistema operativo tiene sus nivles de prioridad que pueden ser distintos de Java (Usar las constantes) *

Se puede conseguir aumentar el rendimiento de una aplicación multithread gestionando las diferentes prioridades de los threads.


THREADS EGOSISTAS
Un thread que entra en Runnable y no sale hasta su murte, impidiendo que otros thread entren en runnable hasta que el muera.
* Ocurre en SOs que no implementan el time-slicing. *

PROGRAMACIÓN EXPULSORA
Java da solución al problema de que el mismo programa Java se ejecute de diferente manera según el SO, dificultando así la portabilidad, a traves del método yield() de la clase java.lang.thread.
  -> yield(), hace que un thread que esta ejecutandose pase a preparado para permitir que otros threads de la misma priority puedan ejecutarse.

Sobre yield() y el egoísmo de los threads hay que tener en cuenta que:
  -> Su funcionamiento no esta garantizado, puede que después de que un thread invoque a yield() y pase a preparado, éste vuelva a ser elegido para ejecutarse.
  -> No se debe asumir que la ejecución de una app se realizará en un SO que implementa time-slicing.
  -> En la app hay que incluir adecuadamente las llamadas a yield(), incluso a sleep() o wait(), si el thread no se bloquea por una E/S.


SINCRONIZACIÓN Y COMUNICACIÓN DE THREAD
Hay ocasiones en las que distintos hilos de un programa necesitan establecer relación entre sí y compartir resources or info.
Dos situaciones entre threads:
  -> Dos o más compiten por obtener un mismo resource.
  -> Dos o más colaboran para obtener un fin común y para ello, necesitan comunicarse a través de algún resoruce.

Para que se ejecuten de manera controlada y coordinada y evitar así posbiles interferencias, utilizamos:
  -> SINCRONIZACIÓN, capadidad de informar de la situación de un hilo a otro, tiene como objetivo establecer la secuencialidad correcta del programa.
  -> COMUNICACIÓN, capacidad de transmitir información de un hilo a otro, tiene como objetivo el intercambio de información entre hilos para operar de forma coordinada.
En Java esto se consigue mediante:
  -> MONITORES, se crean para marcar bloques de código con la palabar synchronized.
  -> SEMÁFOROS, se pueden implementar própios o utilizar la clase Semaphore del paquete java.util.concurrent.
  -> NOTIFICACIONES, permiten comunicar hilos mediante los métodos wait(), notify(), notifyAll() de la clase java.lang.Object.

El paquete java.util.concurrent proporciona varias clases de sincronización que permiten la sincronización y comunicación entre hilos de una app multithreadring -> Semapher, CountDownLatch, CyclicBarrier y Exchanger.


INFORMACIÓN COMPARTIDA ENTRE THREADS
SECCIONES CRÍTICAS, son aquellas secciones de código que no pueden ejecutarse concurrentemente, pues en ellas se encuentran recursos o información que comparten diferentes hilos, y por lo tanto pueden ser problemáticas.

Una forma de proteger secciones críticas es mediante la sincronización, que se consigue mediante:
  -> EXCLUSIÓN MÚTUA, asegurar que un hilo tiene acceso a la sección crítica de forma exclusiva y por un tiempo finito.
  -> POR CONDICIÓN, asegurar que un hilo no progrese hasta que se cumpla una determinada condición.

En Java la sincronización de acceso a recursos compartidos se basa en el concepto de monitor.


MONITORES - MÉTODOS SYNCHRONIZED
Es una porción de código protegida por un mute o lock.

Para crear un monitor en Java, hay que marcar un bloque de códiog con synchronized, pudiendo ser ese bloque:
  -> Un método complet.
  -> Cualquier segmento de código.

Añadir Synchronized a un método significará que:
  -> Se crea un monitor asociado al objeto.
  -> Sólo un thread puede ejecutar el método synchronized de ese objeto a la vez.
  -> Los threads que necesitan acceder al método permanecerán bloqueados y en espera.
  -> Cuando el hilo finaliza la ejecución del método, los hilos en espera de poder ejecutarlo se desbloquearán, el planificador Java seleccionará a uno de ellos.

* Interesa marcar como synchronized los bloques que correspondan a secciones críticas y contengan el código o datos que comparten los hilos.

MONITORES - SEGMENTOS DE CÓDIGO SYNCHRONIZED


























