## DESARROLLO DE LA INTERFAZ DE USUARIO
## LA INTERFAZ DE USUARIO
Una aplicación debe proporcionar una interfaz flexible que se adapte a diferentes configuraciones de pantalla.  
El sistema realiza un escalado y redimensionamiento básico para adaptar la interfaz de usuario a las distintas pantallas, pero hay un trabajo adicional que debemos hacer para asegurar que nuestra interfaz de usuario se adapta correctamente a cada tipo de pantalla.


### LA PANTALLA DE ANDROID
Conceptos:
  - **Tamaño**, longitud de la pantalla en diagonal (***pulgadas***).  
    Android hace cuatro grupos: **small**, **normal**, **large**, **extra large**.
  - **Densidad**, cantidad de píxeles en un área física de la pantalla (***DPI***).  
    Android establece 4 grupos segun la densidad: **LDPI**, **MDPI**, **HDPI**, **XHDPI**. (low, midi, high, extra high).
  - **Resolución**, cantidad de píxeles de la pantalla en horizontal y vertical. Las aplicaciones Android no trabajan directamente con la resolución.
  - **Orientación**, indica si la pantalla del dispositivo se encuentra en vertigal y horizontal.
  - **Pixeles Independientes de la Densidad (DP)**, la unidad de píxel virtual que se utiliza en la definición de un diseño de interfaz de usuario para expresar las dimensiones del diseño o la posición de manera independiente a la densidad.  
Un pixel independiente de la densidad representa un píxel físico en una pantalla de 160 DPI(densidad meida), en tiempo de ejecución.  
El diseño de la interfaz se adapta de forma tranparente al usuario escalando al tamaño adecuado según la pantalla que tenga el dispositivo.

### TAMAÑOS DE PANTALLA
El tamaño de pantalla usado por nuestra app será igual o menor que el tamaño físico real de la pantalla del dispositivo, ya que se añaden las "decoraciones" del sistema.
  
Android agrupa todos los tamaños de pantallas en 4 tamaños genéridos:
  * **small**, pantallas de tamaño similar a una pantalla QVGA de baja densidad (aprox 320x426 dp).
  * **normal**, pantallas de tamaño similara una pantalla HVGA de densidad media (aprox 320x470 dp).
  * **large**, pantallas de tamaño similar a una pantalla VGA de densidad media (aprox 480x640 dp).
  * **extra large**, pantallas más grandes que la pantalla HVGA de densidad media tradicional (aprox 720x960 dp).


### DENSIDAD DE PÍXELES
Hay que evitar definir distancias o tamaños en unidades de píxeles ya que el mismo número de píxeles puede corresponder a diferentes distancias y tamaños en distintos dispositivos físicos.
  
Para preservar el tamaño visible de la IU sobre distintas densidades, hay que diseñarla usando la unidad dp, Android traduce el valor al apropiado número de píxeles reales de cada densidad.

Usar siempre sp(scalable pixels) para definir tamaños de textos.
  
No usar sp nunca para definir tamaños de vistas de diseño


## ORIENTACIÓN DE PANTALLA
Para que la orientación obedezca al sensor de orientación, se pone en el método **onCreate** la siguiente sentencia:

      this.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR

Para mantener fija la orientación:

      //MODO VERTICAL
      android:screenOrientation="landscape"

      //MODO HORIZONTAL
      <activity android:name=".MainActivity">
      android:screenOrientation="portrait"

      //Para que Afecte al método onCreate() directamente
      this.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTAIT
      this.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE


### DISEÑOS FLEXIBLES
Principio fundamental -> Evitar codificar de forma fija (*hard-coding*) la posición y el tamaño de los componentes de la IU, hay que permitir que las vistas puedan cambiiar de tamaño y especificar posiciones de visualización relativas al contenedor u otras vistas hermanas, de forma que el orden prefijado y los tamaños relativos de los componentes permanezcan estables conforme el diseño cambia.
  
Para asegurar un diseño flexible, usar:
  * *warp_content* -> la vista adapta su tamaño al contenido.
  * *match_parent* -> la vista se expande tanto como se pueda en el contenedor.



## USO DE ConstraintLayout
Permite especificar la posición y el tamaño de cada vista acorde a relaciones espaciales con otras vistas del diseño, así, todas las views se pueden mover y ajustar juntas conforme el tamaño de la pantalla varia.
  
*No soluciona todos los escalados de diseño, pero con independencia del diseño usado, se debería evitar el uso de tamaños en el diseño codificados de forma fija.

## CUALIFICADORES DE MÍNIMA ANCHURA
Permite proporcionar diseños alternativos para pantallas que tengan una anchura mínima medida en unidades dp.  
El cualificador de anchura mínima especifica el valor más pequeño de los dos lados, con independencia de la orientación actual del dispositivo, de  tal forma que es una forma sencilla de especificar el tamaño total disponible de pantalla para el diseño.


## CUALIFICADORES DE ANCHURA DISPONIBLE
El diseño cambia basado en la anchura o altura disponible en un momento determinado.


## CUALIFICADORES DE ORIENTACIÓN
Se puede cambiar la UX cuando el user cambia la orientación del dispositivo, para ello, se añade el cualificador ***land*** a los nombres de directorios de recursos.  
Los cualificadores de orientación deben escribirse al final, detrás de otros cualificadores de tamaño.


## CREACIÓN DE DISEÑOS ALTERNATIVOS
Se pueden crear diseños específicos para cada tamaño de pantalla creando directorios adicionales en res/layout uno para cada configuración de pantalla que requiera un diseño distinto y luego añadir un screen configuratión qualifier al nombre del directorio layout.
  
Estos cualificadores representan el espacio visible disponible de pantalla para la interfaz de usuario de la app, por lo tanto será igual o menor que el tamaño físico real de la pantalla del dispositivo ya que hay que tener en cuenta decoraciones del sistema.
  
Para crear diseños alternativos en Android Studio:
  1. Abrir el diseño por defecto de la app.
  2. Clicar en **Orientation for preview** en a barra de herramientas superior en el modulo diseño.
  3. Elegir **Create Landscape Variation**.
  
Esto crea un fichero para la versión apaissada del fichero **activity_main.xml**(landscape).

## DISEÑOS FLEXIBLES CON JetPack Compose
Conjunto de herramientas que aprovecha kotlin, ofrece un enfoque más eficiente y menos complejo para la creación de UI.  
Compose introduce un sistema de UI **reactivo y declarativo**.
  
Permite que los developers definan cómo deberia ser la UI en cualquier momento, mientras que Compose se encarga de actualizar la UI cuando los datos cambian.
  
Principios de Compose que hace que el desarrollo de la UI sea ágil y dinámico:
  - **Diseño Declarativo**, se declaran los componentes que describen la IU en su estado actual, el framework se encargara del renderizado y de las transiciones de estado.
  - **Consistencia**, el códiog de la UI se vuelve más uniforme y menos propenso a errores, ya que la interfaz y la lógica se escriben en el mismo lenguaje.
  - **Interoperabilidad**, está diseñado para integrarse perfectamente con las vistas existentes de Android, lo que permite migrar graduarmente sin necesidad de reescribir las apps por completo.
  - **Mejor Rendimiento**, optimiza el rendimiento al reducir la creación de objetos y la actualización de la jerarquía de vistas, lo cual es beneficioso para interfaces complejas y dinámicas.


## PARADIGMA DECLARATIVO
Representa un cambio significativo en la forma de crear y gestionar las UI en Android, se centra en describir qué debe mostrar la interfaz en un determinado estado de la aplicación.
  
Para actualizar la UI, se llama a la misma función de componibilidad con diferentes argumentos, lo que facilita la asignación de estado a los patrones arquitectónicos.  
Las funciones de compatibilidad son las responsables de transformar el estado actual de la app en una UI cada vez que se actualizan los datos observables.  

**Recomposición**, proceso por el cual se vuelven a dibujar los elementos en una IU.
  
Principales características del paradigma declarativo en Jetpack Compose:
  * **Menos Códiog Repetitivo**, no es necesaro escribir código para cada cambio de estado en la UI, solo se define cómo debería verse la interfaz para un estado dado y Compose actualiza la UI cuando el estado cambia.
  * **UI Como Función de Estado**, las UI se construyen como funciones que la describen en función de su estado, cada vez que los datos cambian, se llama a la función composable correspondiente con el nuevo estado y Compose recompone solo las partes de la UI que necesitan actualizarse.
  * **Recomposición Automática**, cuando el estado de la app cambia, Compose reevalua las funciones composables y actualiza la UI segun sea necesario.
  * **Gestión Simplificada del Estado**, es más facil de manejar el estado en patrones arquitectónicos como ViewModel, el esatdo se pasa a las funciones composables como parámetros y la UI se actualiza automáticamente cuando estos parámetros cambian.


### LAYOUTS EN ANDROID
Son disposiciones de elementos(Views).  
Los gestores de colocación(clases asociadas a cada diseño), permitirán incluir elementos en un contenedor controlando el comportamiento, apariencia y colocación de estos.  
El diseño(layout) puede ser contenedor de uno o varios layouts, pudeiendo establecerse una jerarquía más o menos compleja.  

La clase **ViewGroup** es una vista especial que puede contener otras views, es la base para layouts y contenedores de views, la clase define la clase ViewGroup.LayoutParams la cual sirve como clase base para los parámetros de los layouts.  


Gestores de colocación:
  * **AbsoluteLayout**, posiciona los elementos de forma absoluta.
  * **ConstraintLayout**, permite una edición visual desde el editor y trabajar con porcentajes.
  * **FrameLayout**, permite el cambio dinámico de los elementos que contiene.
  * **LinearLayout**, dispone los elementos en fila o columna.
  * **RelativeLayout**, dispone los elementos en relación a otro o al padre.
  * **TableLayout**, distribuye los elementos de forma tabular.
  * **ScrollView**, hereda de FrameLayout, permite crear vistas desplazables verticalmente.
  
* Estos gestores se han sustituidos por ConstraintLayout de la biblioteca AndroidX de JetPck *
  

## AndroidX - JetPack
Es un namespace que incluye las bibliotecas de Android JetPack.

## Relative Positioning
Elemento básico para crear diseños usando ConstraintLayout, permite posicionar un witget en relación con otro, puede restringirlo en los ejes horizontal y vertical:
  - Horizontal -> left, right, start, end.
  - Vertical -> top, botton, text baseline.























